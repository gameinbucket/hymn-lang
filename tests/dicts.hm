immutable uint64_max = uint64 2000000

int_hashcode(key int) int
	return key

string_hashcode(key string) int
	mutable pos = 0
	mutable value = uint64 0
	length = len(key)
	for value < uint64_max and pos < length
		value = (value << uint64 8) + uint64 key[pos]
		pos += 1
	return int value

type dict_element<v>
	key  int
	value v
	next  maybe<dict_element<v>>

type dict<k, v>
	size     int
	capacity int
	get_code (k) int
	table    []maybe<dict_element<v>>

dict hash_int(code int) int
	return code % self.capacity

dict hash_element(key k) int
	code = self.get_code(key)
	return self.hash_int(code)

dict set(key k, value v)
	bin = self.hash_element(key)
	mutable next = self.table[bin]
	mutable last = none<dict_element<v>>
	for next is some(n)
		if key != n.key : break
		last = next
		next = next.next
	if next is some(n) : if key == n.key : return
	element = dict_element<v>(hash:bin, value:value)
	if next == self.table[bin]
		element.next = next
		self.table[bin] = element
	elif next is none
		last.next = element
	else
		element.next = next
		last.next = element
	self.size += 1

dict get(key k) maybe<v>
	bin = self.hash_element(key)
	match element := self.table[bin]
		some(e) =>
			if key != e.key
				return none
			return e.value
		none => return none

dict has(key k) bool
	return self.get(key) is some

dict delete
	(* todo *)
	self.size -= 1

dict clear
	self.size = 0

main
	m = dict<int, string>(
		size: 10
		capacity: 10
		get_code: int_hashcode)
	m.set(0, "cool")
	out = m.get(0)
	echo(out)
